<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_23) on Tue Jun 28 13:37:11 CEST 2011 -->
<TITLE>
Maths
</TITLE>

<META NAME="date" CONTENT="2011-06-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Maths";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Maths.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../xxl/core/math/Statistics.html" title="class in xxl.core.math"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?xxl/core/math/Maths.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Maths.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
xxl.core.math</FONT>
<BR>
Class Maths</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>xxl.core.math.Maths</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Maths</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The class <code>Maths</code> contains methods that extend the basic numeric
 operations provided in <code>java.lang.Math</code>.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#ZERO">ZERO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Integer that represents the primitive int 0.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#binomialCoeff(int, int)">binomialCoeff</A></B>(int&nbsp;n,
              int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the binomial coefficient (n choose k).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#binomialCoeff2(int, int)">binomialCoeff2</A></B>(int&nbsp;n,
               int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the binomial coefficient (n choose k).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#ceil(int, int)">ceil</A></B>(int&nbsp;i,
     int&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the smallest (closest to negative infinity) value that is not
 less than the first argument and that is equal to a mathematical
 integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#characteristicalFunction(double, double, double)">characteristicalFunction</A></B>(double&nbsp;x,
                         double&nbsp;a,
                         double&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the 'characteristic value' of x regarding to an interval [a,b],
 i.e., 1 if and only if x \in [a,b], 0 otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#doubleToNormalizedLongBits(double)">doubleToNormalizedLongBits</A></B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extracts the mantisse-bits of a double-value d.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#errorEstimation(double[], xxl.core.math.functions.RealFunction, xxl.core.math.functions.RealFunction)">errorEstimation</A></B>(double[]&nbsp;grid,
                <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;orig,
                <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;est)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares two real functions f and g on a grid and computes the local
 errors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#errorEstimation(double, double, int, xxl.core.math.functions.RealFunction, xxl.core.math.functions.RealFunction)">errorEstimation</A></B>(double&nbsp;a,
                double&nbsp;b,
                int&nbsp;n,
                <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;orig,
                <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;est)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares two real functions f and g on a grid and computes the local
 errors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#fac(int)">fac</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the factorial of the given integer value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#fac2(int)">fac2</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the factorial of x, i.e., the product of all positive integers
 less or equal x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#floor(int, int)">floor</A></B>(int&nbsp;i,
      int&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the largest (closest to positive infinity) value that is not
 greater than the first argument and that is equal to a mathematical
 integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#gcd(long, long)">gcd</A></B>(long&nbsp;n,
    long&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the greatest common divisor (gcd) of two long values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#hermitePolynomial(int, double)">hermitePolynomial</A></B>(int&nbsp;r,
                  double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the hermite Polynomial of degree r at x.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#isEven(double)">isEven</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the argument x is even!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#isEven(int)">isEven</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the argument x is even!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#isOdd(double)">isOdd</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the argument x is odd!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#isOdd(int)">isOdd</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the argument x is odd!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#levenshteinDistance(java.lang.String, java.lang.String)">levenshteinDistance</A></B>(java.lang.String&nbsp;s,
                    java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the Levenshtein distance for two given strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#max(java.util.Comparator, T...)">max</A></B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
    T...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum of the given objects according to a comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#max(T...)">max</A></B>(T...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum of the given comparable objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#medianOfThree(java.util.Comparator, T...)">medianOfThree</A></B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
              T...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 3-median-strategy used to compute the pivot element in the
 Quicksort-algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#min(java.util.Comparator, T...)">min</A></B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
    T...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimum of the given objects according to a comparator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#min(T...)">min</A></B>(T...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimum of the given comparable objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;P,A&gt; <A HREF="../../../xxl/core/math/functions/AggregationFunction.html" title="class in xxl.core.math.functions">AggregationFunction</A>&lt;P,java.util.List&lt;A&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#multiDimAggregateFunction(xxl.core.math.functions.AggregationFunction...)">multiDimAggregateFunction</A></B>(<A HREF="../../../xxl/core/math/functions/AggregationFunction.html" title="class in xxl.core.math.functions">AggregationFunction</A>&lt;? super P,A&gt;...&nbsp;functions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method provides a multidimensional aggregation function, that is
 initialized with an arry of aggregation functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#normalizedLongBitsToDouble(long)">normalizedLongBitsToDouble</A></B>(long&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complementary function to <A HREF="../../../xxl/core/math/Maths.html#doubleToNormalizedLongBits(double)"><CODE>doubleToNormalizedLongBits(double d)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#oddFactorial(int)">oddFactorial</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the odd factorial OF(n) = n!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#pDistance(double[], double[], int)">pDistance</A></B>(double[]&nbsp;x,
          double[]&nbsp;y,
          int&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the distance in p-norm of the double[] treated as vectors in a
 real space with dimension of x.length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#pDistance(double, double, int)">pDistance</A></B>(double&nbsp;x,
          double&nbsp;y,
          int&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the distance in the p-norm of double values treated as vectors
 in a real space with dimension 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#qNewton(double, double, xxl.core.functions.Function)">qNewton</A></B>(double&nbsp;start,
        double&nbsp;epsilon,
        <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&lt;? super java.lang.Double,? extends java.lang.Number&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a root computed with the modified Newton method (a special
 root-finding technique ) using a given starting value and a given error
 bound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#qNewton(double, double, xxl.core.math.functions.RealFunction)">qNewton</A></B>(double&nbsp;start,
        double&nbsp;epsilon,
        <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a root computed with the modified Newton method (a special
 root-finding technique ) using a given starting value and a given
 error bound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#rootFinding(double, double, double, xxl.core.functions.Function)">rootFinding</A></B>(double&nbsp;a,
            double&nbsp;b,
            double&nbsp;h,
            <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&lt;? super java.lang.Double,? extends java.lang.Number&gt;&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all roots of a given (continuous) real-valued function as
 <code>double[]</code> using a combination of the modified Newton method
 and a Bisection method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#rootFinding(double, double, double, xxl.core.math.functions.RealFunction)">rootFinding</A></B>(double&nbsp;a,
            double&nbsp;b,
            double&nbsp;h,
            <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all roots of a given (continuous) real-valued function as
 <code>double[]</code> using a combination of the modified Newton method
 and a Bisection method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#signum(double)">signum</A></B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An implementation of the signum function for <code>double</code> values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#signum(long)">signum</A></B>(long&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An implementation of the signum function for <code>long</code> values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../xxl/core/math/Maths.html#triDiagonalGaussianLGS(double[], double[], double[], double[])">triDiagonalGaussianLGS</A></B>(double[]&nbsp;a1,
                       double[]&nbsp;a2,
                       double[]&nbsp;a3,
                       double[]&nbsp;b1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solves a linear system of equations Ax=b for the special case of having
 a tri-diagonal matrix with coefficients a_ij of the matrix A.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ZERO"><!-- --></A><H3>
ZERO</H3>
<PRE>
public static final java.lang.Integer <B>ZERO</B></PRE>
<DL>
<DD>The Integer that represents the primitive int 0.
<P>
<DL>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ceil(int, int)"><!-- --></A><H3>
ceil</H3>
<PRE>
public static final int <B>ceil</B>(int&nbsp;i,
                             int&nbsp;base)</PRE>
<DL>
<DD>Returns the smallest (closest to negative infinity) value that is not
 less than the first argument and that is equal to a mathematical
 integer. This value is computed with the help of the second argument
 <code>base</code> as follows:
 <code><pre>
   return i + i % base == 0 ? 0 : base - i % base;
 </pre></code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - each element returned is greater than this value.<DD><CODE>base</CODE> - rest added to the first argument.
<DT><B>Returns:</B><DD>an integer value that is not less than the first argument
         computed by
         <code>i&nbsp;+&nbsp;i&nbsp;%&nbsp;base&nbsp;==&nbsp;0&nbsp;?&nbsp;0&nbsp;:&nbsp;base&nbsp;-&nbsp;i&nbsp;%&nbsp;base</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="floor(int, int)"><!-- --></A><H3>
floor</H3>
<PRE>
public static final int <B>floor</B>(int&nbsp;i,
                              int&nbsp;base)</PRE>
<DL>
<DD>Returns the largest (closest to positive infinity) value that is not
 greater than the first argument and that is equal to a mathematical
 integer. This value is computed with the help of the second argument
 <code>base</code> as follows:
 <code><pre>
   return i - i % base;
 </pre></code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - each element returned is not greater than this value.<DD><CODE>base</CODE> - rest subtracted from the first argument.
<DT><B>Returns:</B><DD>an integer value that is not greater than the first argument
         computed by <code>i&nbsp;-&nbsp;i&nbsp;%&nbsp;base</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="signum(double)"><!-- --></A><H3>
signum</H3>
<PRE>
public static final int <B>signum</B>(double&nbsp;d)</PRE>
<DL>
<DD>An implementation of the signum function for <code>double</code> values.
 This function returns:
 <ul>
 <li>'1' if the given argument is greater than '0',
 <li>'0' if the given argument is equal to '0',
 <li>'-1' if the given argument is less than '0'.
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - argument to be tested.
<DT><B>Returns:</B><DD>'1' if the given argument is greater than '0', '0' if it is
         equal to it, else '-1'.</DL>
</DD>
</DL>
<HR>

<A NAME="signum(long)"><!-- --></A><H3>
signum</H3>
<PRE>
public static final int <B>signum</B>(long&nbsp;i)</PRE>
<DL>
<DD>An implementation of the signum function for <code>long</code> values.
 This function returns:
 <ul>
 <li>'1' if the given argument is greater than '0',
 <li>'0' if the given argument is equal to '0',
 <li>'-1' if the given argument is less than '0'.
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - argument to be tested.
<DT><B>Returns:</B><DD>'1' if the given argument is greater than '0', '0' if it is
         equal to it, else '-1'.</DL>
</DD>
</DL>
<HR>

<A NAME="min(java.util.Comparator,java.lang.Object[])"><!-- --></A><A NAME="min(java.util.Comparator, T...)"><!-- --></A><H3>
min</H3>
<PRE>
public static final &lt;T&gt; T <B>min</B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                              T...&nbsp;objects)</PRE>
<DL>
<DD>Returns the minimum of the given objects according to a comparator.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the objects to compare.<DT><B>Parameters:</B><DD><CODE>comparator</CODE> - comparator used to compare the given objects.<DD><CODE>objects</CODE> - the objects to be compared.
<DT><B>Returns:</B><DD>the minimum of the given objects according to a comparator.</DL>
</DD>
</DL>
<HR>

<A NAME="min(java.lang.Comparable[])"><!-- --></A><A NAME="min(T...)"><!-- --></A><H3>
min</H3>
<PRE>
public static final &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>min</B>(T...&nbsp;objects)</PRE>
<DL>
<DD>Returns the minimum of the given comparable objects.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the objects to compare.<DT><B>Parameters:</B><DD><CODE>objects</CODE> - the objects to be compared.
<DT><B>Returns:</B><DD>the minimum of the given comparable objects.</DL>
</DD>
</DL>
<HR>

<A NAME="max(java.util.Comparator,java.lang.Object[])"><!-- --></A><A NAME="max(java.util.Comparator, T...)"><!-- --></A><H3>
max</H3>
<PRE>
public static final &lt;T&gt; T <B>max</B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                              T...&nbsp;objects)</PRE>
<DL>
<DD>Returns the maximum of the given objects according to a comparator.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the objects to compare.<DT><B>Parameters:</B><DD><CODE>comparator</CODE> - comparator used to compare the given objects.<DD><CODE>objects</CODE> - the objects to be compared.
<DT><B>Returns:</B><DD>the maximum of the given objects according to a comparator.</DL>
</DD>
</DL>
<HR>

<A NAME="max(java.lang.Comparable[])"><!-- --></A><A NAME="max(T...)"><!-- --></A><H3>
max</H3>
<PRE>
public static final &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>max</B>(T...&nbsp;objects)</PRE>
<DL>
<DD>Returns the maximum of the given comparable objects.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the objects to compare.<DT><B>Parameters:</B><DD><CODE>objects</CODE> - the objects to be compared.
<DT><B>Returns:</B><DD>the maximum of the given comparable objects.</DL>
</DD>
</DL>
<HR>

<A NAME="medianOfThree(java.util.Comparator,java.lang.Object[])"><!-- --></A><A NAME="medianOfThree(java.util.Comparator, T...)"><!-- --></A><H3>
medianOfThree</H3>
<PRE>
public static final &lt;T&gt; T <B>medianOfThree</B>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                        T...&nbsp;objects)</PRE>
<DL>
<DD><p>The 3-median-strategy used to compute the pivot element in the
 Quicksort-algorithm. Three objects are taken from a given object-array,
 namely the left one, the right one and one in the middle. For these
 three elements the median is computed using the given comparator with
 the intention that the median delivers a separation in nearly equal
 parts. If only three objects are specified, the method simply returns
 the median of them. These objects don't need to be pairwise different.
 The implementation is as follows:
 <code><pre>
   T a = objects[0], b = objects[objects.length / 2], c = objects[objects.length];
   
   if (comparator.compare(a, b) <= 0)
       if (comparator.compare(b, c) <= 0)
           return b;
       else                   //i.e. c&lt;b
           return Comparators.max(a, c, comparator);
   else                       //i.e. b&lt;a
       if (comparator.compare(a, c) <= 0)
           return a;
       else                   //i.e. c&lt;a
           return Comparators.max(b, c, comparator);
 </pre></code></p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the objects to compare.<DT><B>Parameters:</B><DD><CODE>comparator</CODE> - comparator used to compare two objects.<DD><CODE>objects</CODE> - the objects to be compared.
<DT><B>Returns:</B><DD>median of three given objects according to a given comparator.</DL>
</DD>
</DL>
<HR>

<A NAME="doubleToNormalizedLongBits(double)"><!-- --></A><H3>
doubleToNormalizedLongBits</H3>
<PRE>
public static long <B>doubleToNormalizedLongBits</B>(double&nbsp;d)</PRE>
<DL>
<DD>Extracts the mantisse-bits of a double-value d.
 
 <p>Precondition: d in [0;1) (i.e. 1.0 excluded).</p>
 
 <p>We use full precision: i.e. bit 10^-1 is at position 62, 10^-2 at
 position 61 and so on. (We do not use bit 63 because bit 63 is
 interpreted as the sign of a long, i.e. the result of long-comparisons
 would not be correct.)</p>
 
 <p>There is no need to store the exponent (=10^-1) or sign (+).</p>
 
 <p><b>Note</b>, that the maximum precision of doubles is then restricted
 to 2^-63=1.08*10^-19. This method is extremely useful to create z-codes
 and to compute replicate-rectangles. The bit-fields can be easily merged
 to a zCode.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - double value where the mantisse-bits should be extracted of.
<DT><B>Returns:</B><DD>a normalized long bit representation of the given double value.</DL>
</DD>
</DL>
<HR>

<A NAME="normalizedLongBitsToDouble(long)"><!-- --></A><H3>
normalizedLongBitsToDouble</H3>
<PRE>
public static double <B>normalizedLongBitsToDouble</B>(long&nbsp;l)</PRE>
<DL>
<DD>Complementary function to <A HREF="../../../xxl/core/math/Maths.html#doubleToNormalizedLongBits(double)"><CODE>doubleToNormalizedLongBits(double d)</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>l</CODE> - a long value that will be interpreted as a normalized long bit
        representation of a double value.
<DT><B>Returns:</B><DD>double value belonging to a given normalized long bit
         representation.</DL>
</DD>
</DL>
<HR>

<A NAME="pDistance(double, double, int)"><!-- --></A><H3>
pDistance</H3>
<PRE>
public static double <B>pDistance</B>(double&nbsp;x,
                               double&nbsp;y,
                               int&nbsp;p)
                        throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Computes the distance in the p-norm of double values treated as vectors
 in a real space with dimension 1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - argument to evaluate. That is (x,y) |--> d(x,y).<DD><CODE>y</CODE> - argument to evaluate. That is (x,y) |--> d(x,y).<DD><CODE>p</CODE> - norm parameter.
<DT><B>Returns:</B><DD>p-distance of x and y.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the dimensions of x,y don't match or
         p&nbsp;&lt;&nbsp;1.</DL>
</DD>
</DL>
<HR>

<A NAME="pDistance(double[], double[], int)"><!-- --></A><H3>
pDistance</H3>
<PRE>
public static double <B>pDistance</B>(double[]&nbsp;x,
                               double[]&nbsp;y,
                               int&nbsp;p)
                        throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Computes the distance in p-norm of the double[] treated as vectors in a
 real space with dimension of x.length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - argument to evaluate. That is (x,y) |--> d(x,y).<DD><CODE>y</CODE> - argument to evaluate. That is (x,y) |--> d(x,y).<DD><CODE>p</CODE> - norm parameter.
<DT><B>Returns:</B><DD>p-distance of x and y.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the dimensions of x,y don't match or
         p&nbsp;&lt;&nbsp;1.</DL>
</DD>
</DL>
<HR>

<A NAME="fac(int)"><!-- --></A><H3>
fac</H3>
<PRE>
public static double <B>fac</B>(int&nbsp;n)
                  throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Computes the factorial of the given integer value. The computation of
 the factorial of a given integer with this method is based upon
 recursion.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - given argument.
<DT><B>Returns:</B><DD>factorial (n!) of the given argument.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the given integer is less than zero
         (n&nbsp;&lt;&nbsp;0)</DL>
</DD>
</DL>
<HR>

<A NAME="oddFactorial(int)"><!-- --></A><H3>
oddFactorial</H3>
<PRE>
public static double <B>oddFactorial</B>(int&nbsp;n)
                           throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Computes the odd factorial OF(n) = n!/2^(n/2)*(n/2)! = (n-1) (n-3) ... 1
 of the even integer value n. The computation of the factorial of any
 given even integer with this method is not based upon recursion.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - even number of type int.
<DT><B>Returns:</B><DD>odd factorial (n!/(2(n/2)!)) of the given argument.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the given integer is less than zero
         (n&nbsp;&lt;&nbsp;0) or odd.</DL>
</DD>
</DL>
<HR>

<A NAME="fac2(int)"><!-- --></A><H3>
fac2</H3>
<PRE>
public static double <B>fac2</B>(int&nbsp;x)
                   throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Computes the factorial of x, i.e., the product of all positive integers
 less or equal x. This version of computing a factorial of any given
 integer does not make use of recursion!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - a integer value.
<DT><B>Returns:</B><DD>x!
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the given integer is less than zero
         (x&nbsp;&lt;&nbsp;0).</DL>
</DD>
</DL>
<HR>

<A NAME="binomialCoeff(int, int)"><!-- --></A><H3>
binomialCoeff</H3>
<PRE>
public static double <B>binomialCoeff</B>(int&nbsp;n,
                                   int&nbsp;k)</PRE>
<DL>
<DD>Computes the binomial coefficient (n choose k).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - first coefficient.<DD><CODE>k</CODE> - second coefficient.
<DT><B>Returns:</B><DD>binomial coefficient (n choose k).</DL>
</DD>
</DL>
<HR>

<A NAME="binomialCoeff2(int, int)"><!-- --></A><H3>
binomialCoeff2</H3>
<PRE>
public static double <B>binomialCoeff2</B>(int&nbsp;n,
                                    int&nbsp;k)</PRE>
<DL>
<DD>Computes the binomial coefficient (n choose k). This method is
 applicable for bigger numbers than allowed in
 <code>binomialCoeff</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - first coefficient.<DD><CODE>k</CODE> - second coefficient.
<DT><B>Returns:</B><DD>binomial coefficient (n choose k).</DL>
</DD>
</DL>
<HR>

<A NAME="triDiagonalGaussianLGS(double[], double[], double[], double[])"><!-- --></A><H3>
triDiagonalGaussianLGS</H3>
<PRE>
public static double[] <B>triDiagonalGaussianLGS</B>(double[]&nbsp;a1,
                                              double[]&nbsp;a2,
                                              double[]&nbsp;a3,
                                              double[]&nbsp;b1)
                                       throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Solves a linear system of equations Ax=b for the special case of having
 a tri-diagonal matrix with coefficients a_ij of the matrix A.
 
 <p>There, a1 represents the upper diagonal axis of the matrix, a2 the 
 diagonal axis of the matrix, a3 the lower diagonal axis of the matrix
 and b1 the solution of the linear equation system.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a1</CODE> - upper diagonal axis of the matrix.<DD><CODE>a2</CODE> - diagonal axis of the matrix.<DD><CODE>a3</CODE> - lower diagonal axis of the matrix.<DD><CODE>b1</CODE> - right side of the equation.
<DT><B>Returns:</B><DD>solution of the linear equation system.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the dimensions of the given double[]
         do not match or the given system is not solvable.</DL>
</DD>
</DL>
<HR>

<A NAME="qNewton(double, double, xxl.core.functions.Function)"><!-- --></A><H3>
qNewton</H3>
<PRE>
public static double <B>qNewton</B>(double&nbsp;start,
                             double&nbsp;epsilon,
                             <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&lt;? super java.lang.Double,? extends java.lang.Number&gt;&nbsp;f)
                      throws java.lang.ArithmeticException</PRE>
<DL>
<DD>Returns a root computed with the modified Newton method (a special
 root-finding technique ) using a given starting value and a given error
 bound.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - starting value for the modified Newton method (special
        root-finding technique).<DD><CODE>epsilon</CODE> - error threshold.<DD><CODE>f</CODE> - real-valued <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions"><CODE>function</CODE></A>.
<DT><B>Returns:</B><DD>root computed with the modified Newton method.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArithmeticException</CODE> - if the numerical method is not contracting,
         i.e., the starting value isn't approximately zero.</DL>
</DD>
</DL>
<HR>

<A NAME="qNewton(double, double, xxl.core.math.functions.RealFunction)"><!-- --></A><H3>
qNewton</H3>
<PRE>
public static double <B>qNewton</B>(double&nbsp;start,
                             double&nbsp;epsilon,
                             <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;f)
                      throws java.lang.ArithmeticException</PRE>
<DL>
<DD>Returns a root computed with the modified Newton method (a special
 root-finding technique ) using a given starting value and a given
 error bound.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - starting value for the modified Newton method (special
        root-finding technique).<DD><CODE>epsilon</CODE> - error threshold.<DD><CODE>f</CODE> - <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions"><CODE>real-valued function</CODE></A>.
<DT><B>Returns:</B><DD>root computed with the modified Newton method.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArithmeticException</CODE> - if the numerical method is not contracting,
         i.e., the starting value isn't approximately zero.</DL>
</DD>
</DL>
<HR>

<A NAME="rootFinding(double, double, double, xxl.core.functions.Function)"><!-- --></A><H3>
rootFinding</H3>
<PRE>
public static double[] <B>rootFinding</B>(double&nbsp;a,
                                   double&nbsp;b,
                                   double&nbsp;h,
                                   <A HREF="../../../xxl/core/functions/Function.html" title="interface in xxl.core.functions">Function</A>&lt;? super java.lang.Double,? extends java.lang.Number&gt;&nbsp;function)</PRE>
<DL>
<DD>Returns all roots of a given (continuous) real-valued function as
 <code>double[]</code> using a combination of the modified Newton method
 and a Bisection method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - left border of the interval where to find the roots.<DD><CODE>b</CODE> - right border of the interval where to find the roots.<DD><CODE>h</CODE> - step width of the step n; Bisection part of the algorithm.<DD><CODE>function</CODE> - function from which to find the roots.
<DT><B>Returns:</B><DD>all found roots of the given function to the given parameters.</DL>
</DD>
</DL>
<HR>

<A NAME="rootFinding(double, double, double, xxl.core.math.functions.RealFunction)"><!-- --></A><H3>
rootFinding</H3>
<PRE>
public static double[] <B>rootFinding</B>(double&nbsp;a,
                                   double&nbsp;b,
                                   double&nbsp;h,
                                   <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;f)</PRE>
<DL>
<DD>Returns all roots of a given (continuous) real-valued function as
 <code>double[]</code> using a combination of the modified Newton method
 and a Bisection method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - left border of the interval where to find the roots.<DD><CODE>b</CODE> - right border of the interval where to find the roots.<DD><CODE>h</CODE> - step width of the step n the bisection part of the algorithm.<DD><CODE>f</CODE> - real function from which to find the roots.
<DT><B>Returns:</B><DD>all found roots of the given function to the given parameters.</DL>
</DD>
</DL>
<HR>

<A NAME="isEven(int)"><!-- --></A><H3>
isEven</H3>
<PRE>
public static boolean <B>isEven</B>(int&nbsp;x)</PRE>
<DL>
<DD>Determines whether the argument x is even!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - integer value.
<DT><B>Returns:</B><DD>true if x is even, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isOdd(int)"><!-- --></A><H3>
isOdd</H3>
<PRE>
public static boolean <B>isOdd</B>(int&nbsp;x)</PRE>
<DL>
<DD>Determines whether the argument x is odd!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - integer value.
<DT><B>Returns:</B><DD>true if x is odd, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isEven(double)"><!-- --></A><H3>
isEven</H3>
<PRE>
public static boolean <B>isEven</B>(double&nbsp;x)
                      throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Determines whether the argument x is even!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - double value, must be element of Z.
<DT><B>Returns:</B><DD>true if x is even, false otherwise.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if x could not be used as an integer
         without loss of information!</DL>
</DD>
</DL>
<HR>

<A NAME="isOdd(double)"><!-- --></A><H3>
isOdd</H3>
<PRE>
public static boolean <B>isOdd</B>(double&nbsp;x)
                     throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Determines whether the argument x is odd!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - double value, must be element of Z.
<DT><B>Returns:</B><DD>true if x is odd, false otherwise.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if x could not be used as an integer
         without loss of information!</DL>
</DD>
</DL>
<HR>

<A NAME="hermitePolynomial(int, double)"><!-- --></A><H3>
hermitePolynomial</H3>
<PRE>
public static double <B>hermitePolynomial</B>(int&nbsp;r,
                                       double&nbsp;x)</PRE>
<DL>
<DD>Computes the hermite Polynomial of degree r at x. The hermite polynomial
 is defined by
 <pre>
   H(0,x) = 1,
   H(1,x) = x and
   H(r,x) = xH(r-1,x) - (r-1) H(r-2,x)
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - degree of the hermite polynomial to compute.<DD><CODE>x</CODE> - function argument.
<DT><B>Returns:</B><DD>hermite polynomial of degree r evaluated at x.</DL>
</DD>
</DL>
<HR>

<A NAME="characteristicalFunction(double, double, double)"><!-- --></A><H3>
characteristicalFunction</H3>
<PRE>
public static double <B>characteristicalFunction</B>(double&nbsp;x,
                                              double&nbsp;a,
                                              double&nbsp;b)</PRE>
<DL>
<DD>Returns the 'characteristic value' of x regarding to an interval [a,b],
 i.e., 1 if and only if x \in [a,b], 0 otherwise.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - value to evaluate.<DD><CODE>a</CODE> - left interval border.<DD><CODE>b</CODE> - right interval border.
<DT><B>Returns:</B><DD>1.0 if x \in [a,b], 0 otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="levenshteinDistance(java.lang.String, java.lang.String)"><!-- --></A><H3>
levenshteinDistance</H3>
<PRE>
public static double <B>levenshteinDistance</B>(java.lang.String&nbsp;s,
                                         java.lang.String&nbsp;t)</PRE>
<DL>
<DD>Computes the Levenshtein distance for two given strings. That means the
 number of transformations to convert one string into the other is
 determined. Transformations are the one-step operations of insertion,
 deletion and substitution.
 
 <p>For details see:
 <ul>
 <li>[Lev66] Levenshtein, V.I. (1966) "Binary codes capable of correcting
 insertions and reversals" Sov. Phys. Dokl. 10:707-10 Algorithm for
 distance computation:</li>
 <li>[NeWu70] Needleman, S.B., Wunsch, C.D. (1970) "A general method
 applicable to the search for similarities in the amino acid sequence of
 two proteins" J. Mol. Biol. 48:443-453</li>
 </ul></p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - first string.<DD><CODE>t</CODE> - second string.
<DT><B>Returns:</B><DD>Levenshtein distance value.</DL>
</DD>
</DL>
<HR>

<A NAME="errorEstimation(double[], xxl.core.math.functions.RealFunction, xxl.core.math.functions.RealFunction)"><!-- --></A><H3>
errorEstimation</H3>
<PRE>
public static double[] <B>errorEstimation</B>(double[]&nbsp;grid,
                                       <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;orig,
                                       <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;est)</PRE>
<DL>
<DD>Compares two real functions f and g on a grid and computes the local
 errors. The functions are evaluated on a given grid that contains n grid
 knots. Computing these criteria is particularly interesting for the
 comparison between an original function and an approximation. Four
 different error criteria are provided:
 <ul>
 <li>L1=(\sum_{x_i in the grid} |f(x_i)-g(x_i)|)/n</li>
 <li>MSE=(\sum_{x_i in the grid} |f(x_i)-g(x_i)|^2)/n</li>
 <li>MXDV=max{|f(x_i)-g(x_i)|,x_i in the grid}</li>
 <li>RMSE=MSE^0.5</li>
 </ul>
 <b>Note:</b> The evaluation of the functions runs unattended, i.e., it
 is not checked if the function is defined on the grid knots!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>grid</CODE> - given grid<DD><CODE>orig</CODE> - function to compare<DD><CODE>est</CODE> - function to compare
<DT><B>Returns:</B><DD>a double array with four values: L1, MSE, MXDV, RMSE</DL>
</DD>
</DL>
<HR>

<A NAME="errorEstimation(double, double, int, xxl.core.math.functions.RealFunction, xxl.core.math.functions.RealFunction)"><!-- --></A><H3>
errorEstimation</H3>
<PRE>
public static double[] <B>errorEstimation</B>(double&nbsp;a,
                                       double&nbsp;b,
                                       int&nbsp;n,
                                       <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;orig,
                                       <A HREF="../../../xxl/core/math/functions/RealFunction.html" title="interface in xxl.core.math.functions">RealFunction</A>&nbsp;est)</PRE>
<DL>
<DD>Compares two real functions f and g on a grid and computes the local
 errors. The functions are evaluated on an equidistant grid that contains
 n grid knots. Computing these criteria is particularly interesting for
 the comparison between an original function and an approximation. Four
 different error criteria are provided:
 <ul>
 <li>L1=(\sum_{x_i in the grid} |f(x_i)-g(x_i)|)/n</li>
 <li>MSE=(\sum_{x_i in the grid} |f(x_i)-g(x_i)|^2)/n</li>
 <li>MXDV=max{|f(x_i)-g(x_i)|,x_i in the grid}</li>
 <li>RMSE=MSE^0.5</li>
 </ul>
 <b>Note:</b> The evaluation of the functions runs unattended, i.e., it is
 not checked if the function is defined on the grid knots.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - left border of the grid.<DD><CODE>b</CODE> - right border of the grid.<DD><CODE>n</CODE> - number of grid knots.<DD><CODE>orig</CODE> - function to compare.<DD><CODE>est</CODE> - function to compare.
<DT><B>Returns:</B><DD>a double array with four values: L1, MSE, MXDV, RMSE.</DL>
</DD>
</DL>
<HR>

<A NAME="multiDimAggregateFunction(xxl.core.math.functions.AggregationFunction...)"><!-- --></A><H3>
multiDimAggregateFunction</H3>
<PRE>
public static &lt;P,A&gt; <A HREF="../../../xxl/core/math/functions/AggregationFunction.html" title="class in xxl.core.math.functions">AggregationFunction</A>&lt;P,java.util.List&lt;A&gt;&gt; <B>multiDimAggregateFunction</B>(<A HREF="../../../xxl/core/math/functions/AggregationFunction.html" title="class in xxl.core.math.functions">AggregationFunction</A>&lt;? super P,A&gt;...&nbsp;functions)</PRE>
<DL>
<DD>This method provides a multidimensional aggregation function, that is
 initialized with an arry of aggregation functions.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>P</CODE> - the type of the values to be aggregated.<DD><CODE>A</CODE> - the type of the aggragate.<DT><B>Parameters:</B><DD><CODE>functions</CODE> - array of aggregation functions.
<DT><B>Returns:</B><DD>multidimensional aggregation function.</DL>
</DD>
</DL>
<HR>

<A NAME="gcd(long, long)"><!-- --></A><H3>
gcd</H3>
<PRE>
public static long <B>gcd</B>(long&nbsp;n,
                       long&nbsp;m)</PRE>
<DL>
<DD>Computes the greatest common divisor (gcd) of two long values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the first long value.<DD><CODE>m</CODE> - the second long value.
<DT><B>Returns:</B><DD>the gcd of n and m.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Maths.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../xxl/core/math/Statistics.html" title="class in xxl.core.math"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?xxl/core/math/Maths.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Maths.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
